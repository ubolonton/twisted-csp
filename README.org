This is a port of https://github.com/olahol/node-csp, with
modifications to suit Python and Twisted, and some improvements.

Other CSP libraries:
- http://code.google.com/p/pycsp/
- https://github.com/python-concurrency/python-csp
- https://github.com/stuglaser/pychan

These libraries use threads/processes (except for pycsp which has support for greenlets). This makes implementation simpler, sacrificing efficiency (but managing threads/processes can be a chore). On the other hand they are much more generic, and support networked channels (that is not necessarily a good thing though).
TODO: More elaborate comparison of different approaches.

Inspiration: http://swannodette.github.io/2013/08/24/es6-generators-and-csp

To run an example, use the =run= script, like:
#+begin_src shell
./run example.blocking
#+end_src
Note that each example must be terminated manually since the event
loop is still running after all the processes finish.

Limitations (either fundamental to the approach, or of the implementation):

- No "deep" yield. Therefore it is impossible to extract pieces of
  logic that does channel communication without spawning a new process
  (maybe python 3 ("yield from") will help?). This can reduce composability.
- Need a running event loop.
- Channel's normal API cannot be used outside of a process (more
  precisely outside of the generator function of a process). Another
  set of API would be needed for that.
- Cooperative scheduling (usually this is not a big problem, except
  when combined with the next point).
- Forgetting to yield causes bug (value not being put on channel,
  infinite loop blocking thread (Go/Clojure do not have this problem
  because single syntactic units are used there, as opposed to "yield"
  plus "function")).

A possible problem with all implementations: alt can only be first-class if it is a built-in language feature (Go), or if the language has macros (Clojure). In Python alts usually:
- Select only on reads.
- Use clunky syntax for selecting from a mix of reads/writes.
- Pass string to be evaluated as code.

#+begin_src python
import csp

class Ball:
    hits = 0


def player(name, table):
    while True:
        ball = yield table.take()
        ball.hits += 1
        print name, ball.hits
        # Forgot to yield => lightning fast pingpong player!
        csp.wait(0.1)
        yield table.put(ball)


def main():
    table = csp.Channel()

    yield csp.go(player, "ping", table)
    yield csp.go(player, "pong", table)

    yield table.put(Ball())
    yield csp.wait(1)


# Infinite loop, blocking threaod
def processing(chan):
    yield csp.wait(0.1)
    while True:
        # Forgot to yield => hold control indefinitely
        chan.take()
#+end_src


#+begin_src python

def foo(in, out):
    v = yield in.take()
    yield out.put(v)
    # Do something else


def send(in, out):
    v = yield in.take()
    yield chan2.put(v)


def foo1(in, out):
    process = yield csp.spawn(send, in, out)
    yield csp.wait(process)

#+end_src

# TODO
API:
csp.Channel
csp.go
csp.spawn
csp.process
csp.select
csp.wait
csp.channelify
